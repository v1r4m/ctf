## overall
토요일, 20 12 2025, 09:00 KST — 월요일, 22 12 2025, 09:00 KST
### Team Rank
* 1447 score
* #25
### diary
연말이고만 . . . . .
### crypto
`ntt` 문제를 보자마자 지금 플래그를 찾는게 문제가 아니라는걸 깨닫고 고속 푸리에변환과 ntt에 대해서 공부를 함 하튼 내가 감을 잡은건...고속 푸리에변환이란 다항식의 곱을 O(n^2)가 아니라 O(nlogn)에 하기 위해 만들어진 어쩌고이다. 다항식의 곱을 왜하냐... 수학자들이 할 필요가 있으시니까 하시겟죠. 그런데 암호학에서도 다항식의 곱을 활용할 수 있다. 평문A에 키B를 곱하고 노이즈를 얹으면 그게바로 훌륭한 암호문. 

ntt는 이 고속 푸리에변환을 정수계수로만 한정한 것인데 잘 몰으겟지만 정수라는 가정이 있으므로 더 정확하고 무결성을 보장할 수 있는 어쩌고... 그런데 우리가 다항식의 곱이라고 하는 것을 보면 알겠지만 다항식의 곱은 한 계수와 암호문의 모든 계수가 곱해지고 더해진것이므로 암호문의 모든 계수가 암호문에 영향을 준다고 볼 수 있다. 그렇기에 여기서 leak가 터지면 취약점으로 파고들 수 있는것...

문제에서는 평문을 8섹터로 나눠서 각 섹터마다 넣을 수 있는 노이즈의 오차범위를 제시했고 가장 작은게 +- 70인가? 그랬고 256바이트였으니까 경우의 수가 140의 256승인가 그랬던거같다 ㅋㅋ 그럼에도 노이즈의 오차범위가 작은곳에서 풀이를 시도해야겠다고 생각했는데 

여기서부터는 같은 팀원 앤소님의 풀이... 당연히 140의 256승을 계산할 수는 없고 대신 계수가 -2,-1,0,1,2로 제한되어 있으니까 ... 그리고 ntt의 stage0이 계산되는 원리를 알아야하는데 stage0에서는 (s[0],s[128]), (s[1],s[129]), ... (s[127],s[255]) 이런식으로 계산이된다는 걸 고려해서 `s[0] + zeta*s[i+128]` 과 `s[0]-zeta*s[i+128]` 모두 leak +- delta 의 범위에 속해야하는 것이다. 그런데 s가 될수있는건 5개밖에 없으니까 총 25개의 경우의 수 중...ㅇㅇ 추릴 수 있는것이지

stage0을 그렇게 하면 s의 가능한 리스트가 나올텐데 stage1을 다시 돌리면서 stage0과 stage1을 동시에 만족하는걸 찾고 그다음엔 stage2를 찾고... 일케 당연히 내가 본것처럼 stage7인가 거기가 엄청 타이트한 델타를 가지고 있으므로 거기서 아마 많이 걸러질것이다. 

앤소님 풀이에서 신기한것은 parity를 분리했다는 건데 kyber ntt구조는 짝수트리와 홀수트리가 완전히 독립적으로 연산된다고 한다. (인덱스에 128을 더하므로 조금 생각해보면 어쩌면 당연한 이야기) 다 그런건 아니고 kyber ntt만 그렇다고 하네. 대단해! 역시 푸리에변환을 증명하진 못하더라도 ntt의 계산을 손으로 drive해봤어야 햇다. 

### misc 
`mb` 내가 풀려고 시도했던거나 정답풀이나 아이디어는 같은게 결국엔 픽셀이란 기댓값이라는 아이디어에서 출발하는 것이다. 나는 motion path를 찾는것부터 너무 어려웠는데, 솔브롸업을 보니까 모션이 움직인다는걸 아예 무시하고 프레임별로 모자이크만 찾던데.. 좋은것같다..ㅅㅂ , , ,

모자이크를 어떻게 찾을까? 결국 특정 범위 내에서 variance가 충분히 낮으면 모자이크라고 볼 수 있다. 특정 범위는 어떻게 찾을까? 이 아이디어도 굉장히 괜찮은데 우리는 모자이크가 `16*16`임을 알고있으므로 이미지의 왼쪽 상단에 0~16, 0~16의 범위를 갖는(256) margin을 설정하여 거기서부터 `16*16`으로 모든 이미지를 쪼갠다. 모든 프레임에 모자이크가 있으므로 '잘 쪼개면' 유의미하게 variance가 낮아지는 순간이 있는데 이렇게 찾으면 모자이크의 위치를 알 수 있다 오오 똑똑해 오오

그 뒤는 기본적인 디모자이크 로직과 비슷하게 '픽셀은 기댓값'이라는 논리로 풀어나가면 되고.... 안티앨리어싱도 신경쓰였는데 경계 스무딩이 있어도 평균에는 큰 영향이 없다는 가정하에 풀어나간것이다

단순 평균은 이미지의 구조적 특성을 무시하고 픽셀값을 혼합하는거다. 당연히 기댓값이긴 하지만? 이를테면 픽셀(100,100)이 프레임1에서는 블록A에 왼쪽 이에 있고, 다음 프레임에서는 블록B의 오른쪽 아래에 있으면 '주변의 픽셀이'영향을 당연히 줄텐데 이게 100,100의 rgb값에는 노이즈로 작용한다. 그러므로 '블록단위로'계산하여 블록 내 픽셀들이 '함께 조정되어야'하는거지.

프레임1에서 120, 2에서 130이었다면 기댓값 125라는것밖에 알 수 없지만, 프레임1에서는 0,0 오프셋으로 120이었다면 0~16, 0~16 블록에서 120의 기댓값 설정해두고 0,1 블록에 130, 1,1블록에 140, 1,0 블록에 140이라고 하면 프레임2에서는 8,8오프셋으로 130이라고 할 때 8*8만 120, 나머지 8*8은 130, 8*8은 140, 8*8은 140의 기댓값을 가지고있었는데 여기서 블록 평균이 130이 될 수 있도록 1,1블록 평균보다 왼쪽위가 좀 더 밝다는걸 유추할 수 있겠지. 이걸 식으로 어떻게 표현하지? (A + B + C + D) / 4 = 120 그리고 (D + E + F + G) / 4 = 130 라는 연립방정식을 푼다고 생각하면 직관적이다. 

그래서 어케하냐면 gradient descent이다. 현재 배열에 있는값과 관측값이 obs-cur만큼 차이나니까 둘이 같아지도록 그 차이*learning rate(<1)만큼 조정해주는 것이다. 결국엔 ML임! 재밌도다 재밌도다